<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>App Prototype – Scenes + Swipe + Zoom/Fade</title>
  <style>
    :root{ --app-bg: transparent; --menubar-height: 64px; --phone-radius: 28px; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: #0d0f12; color: #eaeaea; font-family: system-ui, sans-serif; }
    .wrap { height: 100dvh; display: grid; place-items: center; padding: 2.5vmin; }
    .phone { aspect-ratio: 9 / 16; width: min(92vw, 56.25vh); background: var(--app-bg); border-radius: var(--phone-radius); box-shadow: 0 30px 80px rgba(0,0,0,.5), 0 6px 18px rgba(0,0,0,.35); overflow: hidden; display: grid; grid-template-rows: 1fr var(--menubar-height); border: 1px solid rgba(255,255,255,.06); }
    .stage { position: relative; overflow: hidden; touch-action: none; background: transparent; display: grid; place-items: center; }

    .zoom-content { position: relative; width: 100%; height: 100%; transform-origin: 0 0; will-change: transform; image-rendering: optimizeQuality; }

    /* --- Scenes wrapper slides horizontaal --- */
    .scenes { position: absolute; inset: 0; display: grid; grid-auto-flow: column; grid-auto-columns: 100%; height: 100%; width: 100%; transform: translateX(0%); }
    .scenes.anim { transition: transform 320ms cubic-bezier(.22,.61,.36,1); }

    .scene { position: relative; width: 100%; height: 100%; }
    .layer { position: absolute; inset: 0; display: grid; place-items: center; transition: opacity 220ms ease; pointer-events: none; }
    .layer svg { width: 100%; height: 100%; object-fit: contain; pointer-events: auto; vector-effect: non-scaling-stroke; shape-rendering: geometricPrecision; }

    .menubar { display: grid; grid-template-columns: repeat(5, 1fr); align-items: center; padding: 0 12px; background: rgba(10,12,15,.6); backdrop-filter: blur(8px); border-top: 1px solid rgba(255,255,255,.08); }
    .menu-dot { justify-self: center; width: 8px; height: 8px; border-radius: 999px; background: rgba(255,255,255,.5); }

    .scale-indicator { position: absolute; right: 10px; top: 10px; z-index: 10; font-size: 12px; padding: 4px 8px; border-radius: 10px; background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.12); display: none; }
    .svg-button:focus { outline: 2px solid currentColor; outline-offset: 2px; }

    /* hint voor scene-indicator (optioneel) */
    .scene-chip { position: absolute; left: 10px; top: 10px; z-index: 10; font-size: 12px; padding: 4px 8px; border-radius: 10px; background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.12); }
  .hotspot-ring { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
      width: 96px; height: 96px; border-radius: 999px; background: transparent; color: #fff;
      display: grid; place-items: center; font-weight: 700; font-size: 12px;
      border: 3px solid rgba(255,255,255,.95); box-shadow: 0 0 0 6px rgba(255,255,255,.18), 0 8px 24px rgba(0,0,0,.45);
      cursor: pointer; user-select: none; backdrop-filter: blur(2px);
    }
    .hotspot-ring::after { content: 'NU'; font-size: 14px; letter-spacing: 0.08em; background: rgba(0,0,0,.55); padding: 6px 10px; border-radius: 999px; border: 1px solid rgba(255,255,255,.25); }
    .hotspot-ring:hover { box-shadow: 0 0 0 8px rgba(255,255,255,.26), 0 10px 28px rgba(0,0,0,.55); }
    .hotspot-ring:focus { outline: 2px solid #fff; outline-offset: 2px; }
    .hotspot:hover { background: rgba(0,0,0,.7); }
    .hotspot:focus { outline: 2px solid #fff; outline-offset: 2px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="phone" id="phone">
      <div class="stage" id="stage" tabindex="0" aria-label="Scènes: sleep met muis om te wisselen; Spatie wisselt scène; scroll/pinch om te zoomen">
        <div class="scale-indicator" id="scaleOut">1.00×</div>
        <div class="zoom-content" id="zoomContent">
          <div class="scenes anim" id="scenes">

            <!-- Scene 0: Tuin / Schuur / Binnenkant -->
            <section class="scene" id="sceneTuin">
              <div class="scene-chip" id="chip">Tuin</div>
              <div class="layer" id="layerTuin" style="opacity:1"><!-- inline SVG --></div>
              <div class="layer" id="layerSchuur" style="opacity:0"><!-- inline SVG --></div>
              <div class="layer" id="layerBinnenkant" style="opacity:0"><!-- inline SVG --></div>
            </section>

            <!-- Scene 1: Huis / Woonkamer / Dessoir -->
            <section class="scene" id="sceneHuis">
              <div class="scene-chip">Huis</div>
              <div class="layer" id="layerHuis" style="opacity:1"><!-- inline SVG --></div>
              <div class="layer" id="layerWoonkamer" style="opacity:0"><!-- inline SVG --></div>
              <div class="layer" id="layerDessoir" style="opacity:0"><!-- inline SVG --></div>
            </section>

          </div>
        </div>
      </div>
      <nav class="menubar">
        <div class="menu-dot"></div><div class="menu-dot"></div><div class="menu-dot"></div><div class="menu-dot"></div><div class="menu-dot"></div>
      </nav>
    </div>
  </div>
  <script>
    // --- Zoom configuratie ---
    const MIN_SCALE = 1, MAX_SCALE = 6, WHEEL_ZOOM_SPEED = 0.0018;
    const SCHUUR_FADE_IN_START = 1.6, SCHUUR_FADE_IN_END = 2.4; // scene 0 middle
    const BINNEN_FADE_IN_START = 2.8, BINNEN_FADE_IN_END = 4.0; // scene 0 top
    const WOONKAMER_FADE_IN_START = 1.6, WOONKAMER_FADE_IN_END = 2.4; // scene 1 middle
    const DESSOIR_FADE_IN_START = 2.8, DESSOIR_FADE_IN_END = 4.0; // scene 1 top

    const stage = document.getElementById('stage');
    const zoomContent = document.getElementById('zoomContent');
    const scenesWrap = document.getElementById('scenes');

    // Scene 0 layers
    const layerTuin = document.getElementById('layerTuin');
    const layerSchuur = document.getElementById('layerSchuur');
    const layerBinnen = document.getElementById('layerBinnenkant');
    // Scene 1 layers
    const layerHuis = document.getElementById('layerHuis');
    const layerWoonkamer = document.getElementById('layerWoonkamer');
    const layerDessoir = document.getElementById('layerDessoir');
    // Dessoir-hotspot (nu.nl)
    const hotspot = document.createElement('button');
    hotspot.className = 'hotspot-ring';
    hotspot.type = 'button';
    hotspot.title = 'Open NU.nl in nieuw tabblad';
    hotspot.setAttribute('aria-label','Open NU.nl');
    hotspot.style.display = 'none';
    hotspot.addEventListener('click', (e)=>{ e.preventDefault(); window.open('https://www.nu.nl','_blank','noopener'); });
    hotspot.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); window.open('https://www.nu.nl','_blank','noopener'); }});
    layerDessoir.appendChild(hotspot);

    const scaleOut = document.getElementById('scaleOut');

    let scale=1, originX=0.5, originY=0.5;
    // Pan-translate zodat we op een ankerpunt kunnen zoomen zonder verspringen
    let tx=0, ty=0;
    let sceneIndex = 0; // 0: tuin, 1: huis

    const clamp=(v,a,b)=>Math.min(Math.max(v,a),b);
    const invLerp=(a,b,v)=>(v-a)/(b-a);

    // --- Inline loader ---
    async function loadInlineSVG(url, targetEl){
      try{
        const res = await fetch(url, { cache:'no-cache' });
        if(!res.ok) throw new Error(`HTTP ${res.status}`);
        const txt = await res.text();
        const cleaned = txt.replace(/<\?xml[^>]*>/g,'').trim();
        targetEl.innerHTML = cleaned;
        const svg = targetEl.querySelector('svg');
        if(!svg) throw new Error('No <svg>');
        svg.setAttribute('width','100%');
        svg.setAttribute('height','100%');
        svg.setAttribute('preserveAspectRatio','xMidYMid meet');
        enhanceSvgButtons(svg);
        analyzeSvg(svg, url);
        return svg;
      }catch(err){
        console.warn('Inline load failed for', url, err);
        targetEl.innerHTML = `<img src="${url}" alt="${url}" style="width:100%;height:100%;object-fit:contain"/>`;
        showLoadWarning();
        return null;
      }
    }

    function showLoadWarning(){
      if(document.getElementById('inlineWarn')) return;
      const note=document.createElement('div');
      note.id='inlineWarn';
      note.textContent='Let op: om interactieve SVG’s te laten werken, open dit bestand via http(s) (bijv. lokaal: python -m http.server).';
      Object.assign(note.style,{position:'absolute',left:'12px',right:'12px',bottom:'80px',background:'rgba(0,0,0,0.65)',color:'#fff',padding:'10px 12px',border:'1px solid rgba(255,255,255,0.2)',borderRadius:'10px',fontSize:'12px',zIndex:50});
      stage.appendChild(note); setTimeout(()=>note.remove(),6000);
    }

    let suppressClicksUntil = 0;
    const suppressClicks = (ms=500)=>{ suppressClicksUntil = Date.now() + ms; };
    const shouldSuppressClick = ()=> Date.now() < suppressClicksUntil;

    function analyzeSvg(svg, name){
      try {
        const imgs = svg.querySelectorAll('image');
        if (imgs.length) {
          console.warn(`[${name}] bevat ${imgs.length} raster <image>-element(en). Bij ver inzoomen kan dit onscherp lijken als de bronresolutie laag is.`);
        }
      } catch {}
    }

    function enhanceSvgButtons(svg){
      // Verbeter scherpte (ook als er <image> bitmaps in de SVG zitten)
      try {
        svg.style.shapeRendering = 'geometricPrecision';
        svg.style.textRendering = 'optimizeLegibility';
        svg.style.imageRendering = 'optimizeQuality';
        // Forceer crisper rendering voor embedded bitmaps
        svg.querySelectorAll('image').forEach(imgEl => {
          imgEl.style.imageRendering = 'crisp-edges';
          imgEl.style.imageRendering = 'pixelated'; // fallback voor sommige engines
        });
      } catch {}

      const btns = svg.querySelectorAll('[data-action], [role="button"], .btn, .button, a');
      btns.forEach(el=>{
        el.classList.add('svg-button');
        if(!el.hasAttribute('tabindex')) el.setAttribute('tabindex','0');
        if(!el.hasAttribute('role')) el.setAttribute('role','button');
        el.style.cursor='pointer';
        el.addEventListener('click', (e)=>{
          if (shouldSuppressClick()) { e.preventDefault(); e.stopPropagation(); return; }
          e.preventDefault(); window.open('https://www.nu.nl','_blank','noopener');
        }, { capture: true });
        el.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' '){ if (shouldSuppressClick()) { e.preventDefault(); return; } e.preventDefault(); window.open('https://www.nu.nl','_blank','noopener'); }});
      });
    }

    // --- Opacity per scene ---
    function updateOpacity(){
      if (sceneIndex === 0){
        // Scene Tuin
        if (layerTuin) layerTuin.style.opacity = 1;
        if (layerSchuur) layerSchuur.style.opacity = (scale<=SCHUUR_FADE_IN_START) ? 0 : (scale>=SCHUUR_FADE_IN_END) ? 1 : clamp(invLerp(SCHUUR_FADE_IN_START,SCHUUR_FADE_IN_END,scale),0,1);
        if (layerBinnen) layerBinnen.style.opacity = (scale<=BINNEN_FADE_IN_START) ? 0 : (scale>=BINNEN_FADE_IN_END) ? 1 : clamp(invLerp(BINNEN_FADE_IN_START,BINNEN_FADE_IN_END,scale),0,1);
        // Klikken alleen op zichtbare scene 0
        [layerTuin, layerSchuur, layerBinnen].forEach(layer=>{ const svg=layer?.querySelector('svg'); if(svg) svg.style.pointerEvents = (parseFloat(layer.style.opacity||'0')>0.02) ? 'auto':'none'; });
        [layerHuis, layerWoonkamer, layerDessoir].forEach(l=>{ const svg=l?.querySelector('svg'); if(svg) svg.style.pointerEvents='none'; });
        if (hotspot) hotspot.style.display = 'none';
      } else {
        // Scene Huis
        if (layerHuis) layerHuis.style.opacity = 1;
        if (layerWoonkamer) layerWoonkamer.style.opacity = (scale<=WOONKAMER_FADE_IN_START) ? 0 : (scale>=WOONKAMER_FADE_IN_END) ? 1 : clamp(invLerp(WOONKAMER_FADE_IN_START,WOONKAMER_FADE_IN_END,scale),0,1);
        if (layerDessoir) layerDessoir.style.opacity = (scale<=DESSOIR_FADE_IN_START) ? 0 : (scale>=DESSOIR_FADE_IN_END) ? 1 : clamp(invLerp(DESSOIR_FADE_IN_START,DESSOIR_FADE_IN_END,scale),0,1);
        // Klikken alleen op zichtbare scene 1
        [layerHuis, layerWoonkamer, layerDessoir].forEach(layer=>{ const svg=layer?.querySelector('svg'); if(svg) svg.style.pointerEvents = (parseFloat(layer.style.opacity||'0')>0.02) ? 'auto':'none'; });
        [layerTuin, layerSchuur, layerBinnen].forEach(l=>{ const svg=l?.querySelector('svg'); if(svg) svg.style.pointerEvents='none'; });
        if (hotspot){
          const vis = parseFloat(layerDessoir?.style.opacity || '0') > 0.9;
          hotspot.style.display = vis ? 'grid' : 'none';
        }
      }
    }

    function applyTransform(){
      // translate eerst, dan scale, met origin 0,0
      zoomContent.style.transform = `translate(${tx.toFixed(3)}px, ${ty.toFixed(3)}px) scale(${scale.toFixed(4)})`;
      const scaleOut = document.getElementById('scaleOut');
      if (scaleOut) scaleOut.textContent = `${scale.toFixed(2)}×`;
    }

    function setScale(next, anchorX=null, anchorY=null){
      const prev = scale;
      let target = clamp(next, MIN_SCALE, MAX_SCALE);

      // Als we aan het uitzoomen zijn en we zitten bijna op 1: snap terug naar de beginstand
      if (target <= 1.05 && target < prev) {
        scale = 1; tx = 0; ty = 0; // recentreer scene
        updateOpacity();
        applyTransform();
        return;
      }

      scale = target;

      // Houd het wereldpunt onder de cursor vast
      if (anchorX !== null && anchorY !== null){
        const ux = (anchorX - tx) / prev;
        const uy = (anchorY - ty) / prev;
        tx = anchorX - scale * ux;
        ty = anchorY - scale * uy;
      }
      updateOpacity();
      applyTransform();
    }


    // --- Swipe/scene wissel ---
    let swipeActive = false;
    let swipeStartX = 0;
    let swipeDX = 0;
    const SWIPE_MIN_SCALE = 1.25; // iets ruimer: swipe toestaan als je (bijna) uitgezoomd bent
    const SWIPE_THRESHOLD_PX = 50; // iets lager zodat het sneller pakt // minimale sleepafstand om te wisselen

    function setScene(nextIndex, animate=true){
      sceneIndex = clamp(nextIndex, 0, 1);
      scenesWrap.classList.toggle('anim', !!animate);
      scenesWrap.style.transform = `translateX(${-sceneIndex*100}%)`;
      // reset view (optioneel weghalen om pan/zoom te bewaren)
      scale = 1; tx = 0; ty = 0;
      updateOpacity();
      applyTransform();
      const chip = document.getElementById('chip');
      if (chip) chip.textContent = sceneIndex===0 ? 'Tuin' : 'Huis';
    }

    // Wheel zoom
    stage.addEventListener('wheel', (e)=>{
      e.preventDefault();
      const r=stage.getBoundingClientRect();
      const ax = e.clientX - r.left; // anchor px in stage
      const ay = e.clientY - r.top;
      const d=-e.deltaY*WHEEL_ZOOM_SPEED;
      const next = scale * (1 + d);
      setScale(next, ax, ay);
    }, { passive:false, capture:true });

    // Pinch zoom + Mouse drag (geen touch swipe) – CLEAN STATE
    const active = new Map();
    const getCentroid=()=>{let sx=0,sy=0;const arr=[...active.values()];for(const p of arr){sx+=p.x;sy+=p.y;}return {x:sx/arr.length,y:sy/arr.length}};
    const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
    let pinchStartDist=0,pinchStartScale=1;

    let dragActive=false; let dragStartX=0; let dragDX=0; // scene-drag

    stage.addEventListener('pointerdown', (e)=>{
      stage.setPointerCapture(e.pointerId);
      active.set(e.pointerId,{x:e.clientX,y:e.clientY,type:e.pointerType,button:e.button});
      if (e.pointerType==='mouse' && e.button===0 && scale <= SWIPE_MIN_SCALE){
        dragActive = true; dragStartX = e.clientX; dragDX = 0; scenesWrap.classList.remove('anim');
      }
      if (active.size===2){
        const [p1, p2] = [...active.values()];
        pinchStartDist = dist(p1,p2);
        pinchStartScale = scale;
        dragActive = false;
      }
    }, {capture:true});

    function endPointer(e){
      if (active.has(e.pointerId)) active.delete(e.pointerId);
      if (dragActive && (e.pointerType==='mouse' || active.size===0)){
        scenesWrap.classList.add('anim');
        if (Math.abs(dragDX) > SWIPE_THRESHOLD_PX){
          if (dragDX < 0 && sceneIndex < 1) { setScene(sceneIndex+1); suppressClicks(); }
          else if (dragDX > 0 && sceneIndex > 0) { setScene(sceneIndex-1); suppressClicks(); }
          else setScene(sceneIndex);
        } else { setScene(sceneIndex); }
        dragActive = false; dragDX = 0;
      }
    }
    stage.addEventListener('pointermove', (e)=>{
      if (!active.has(e.pointerId)) return;
      active.set(e.pointerId,{x:e.clientX,y:e.clientY,type:e.pointerType});
      // Pinch: twee pointers -> schaal op centroid
      if (active.size===2){
        const [p1,p2]=[...active.values()];
        const d=dist(p1,p2);
        const r=stage.getBoundingClientRect();
        const c=getCentroid();
        const ax=c.x - r.left; const ay=c.y - r.top; // pinch centroid als anker
        const next = pinchStartScale*(d/(pinchStartDist||d));
        setScale(next, ax, ay);
        return;
      }
      // Drag slide tussen scenes
      if (dragActive && e.pointerType==='mouse'){
        dragDX = e.clientX - dragStartX;
        const w = stage.clientWidth;
        const pct = (-sceneIndex*100) + (-dragDX / w * 100);
        scenesWrap.style.transform = `translateX(${pct}%)`;
      }
    }, {capture:true});

    stage.addEventListener('pointerup', endPointer, {capture:true});
    stage.addEventListener('pointercancel', endPointer, {capture:true});
    stage.addEventListener('pointerleave', endPointer, {capture:true});

    // Toetsenbord: Spatie toggelt tussen scènes
    stage.addEventListener('keydown', (e)=>{
      if (e.code==='Space' || e.key===' ') { e.preventDefault(); setScene(sceneIndex===0?1:0); }
    }, {capture:true});

    // Double-tap to zoom toggle
    let lastTap=0;
    stage.addEventListener('click',(e)=>{ const now=Date.now(); if(now-lastTap<300){ const r=stage.getBoundingClientRect(); const px=(e.clientX-r.left)/r.width; const py=(e.clientY-r.top)/r.height; setScale(scale<2?2:1,px,py); } lastTap=now; }, {capture:true});

    // Init
    (async function(){
      // Scene 0
      await loadInlineSVG('Tuin.svg', layerTuin);
      await loadInlineSVG('Schuur.svg', layerSchuur);
      await loadInlineSVG('Binnenkant.svg', layerBinnen);
      // Scene 1
      await loadInlineSVG('huis.svg', layerHuis);
      await loadInlineSVG('woonkamer.svg', layerWoonkamer);
      await loadInlineSVG('dessoir.svg', layerDessoir);
      updateOpacity();
      applyTransform();
      setScene(1, false); // start met HUIS als eerste zichtbare scene
      try{ stage.focus({preventScroll:true}); }catch{}
    })();
  </script>
</body>
</html>
